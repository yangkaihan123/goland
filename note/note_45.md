# 45 概念

map 是引用类型，可以如下声明

```go
var map1 map[keytype]valuetype
var map1 map[string]int
```

(`[keytype]` 和 `valuetype` 之间允许有空格，但是 gofmt 移除了空格)

在声明的时候不需要知道 map 的长度，map 是可以动态增长的。

未初始化的 map 的值是 nil。

key 可以是任意可以用的 == 或者 != 操作符比较的类型，比如 string，int， float。  
所以数组，切片和结构体不能作为 key ，含有数组切片的结构体不能作为 key ，只包含内建类型的 struct 是可以作为key的，但是指针类型和接口类型可以作为 key ，如果要用结构体作为 key
可以提供 `key()` 和 `Hash()` 方法，这样可以通过结构体的域计算出唯一的数字或字符串的 key 。  

value 可以是任意类型的；通过使用空接口类型，可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言。

map 传递给函数的代价很小： 在32为机器上占4个字节，64位机器上占8个字节，无论实际上存储了多少数据。通过 key 
在 map 中寻找值是很快的，比线性查找快得很多，但是仍然比从数组或切片的索引中直接读取要慢很多，所以在乎性能的时候
还是切片解决问题好。  

map 也可以用函数做值，这样就可以用来做分支结构（控制结构，for switch 那些）：key 用来选择要执行的函数。

如果 key1 是 map1 的 key ，那么 `map1[key1]` 就是对应的 key1 的值，就如同数组索引的符号一样（数组可以视为一种简单形式的 map ，key 是从
0开始的整数）。

key1 对应的值可以通过赋值符号来设置为 val1 : `map1[key1] = val1` 。

令`v := map1[key1]` 可以将 key1 的对应值赋值给 v ； 如果 map 中没有 key1 存在，那么 v 将赋值为 map1 的值类型的空值。

这个空值的解释： `map1[string]int` 当这个 string 的 key 的值是空的话， 那么 v 就是 int 的 nil 值。

常用的 `len(map1)` 方法可以直接获取到 map 中的 pair 数目，这个数目是可以伸缩的，因为 map-pairs 在运行






















